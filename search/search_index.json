{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Earthformer","text":"<p>A Python package for Earth forecasting transformer</p> <ul> <li>Free software: Apache License, Version 2.0 (Apache-2.0)</li> <li>Documentation: https://opengeos.github.io/earthformer</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>This repository turns the amazon-science/earth-forecasting-transformer repository into a Python package, making it easier to install and use. To learn more about Earthformer, please refer to the NeurIPS 2022 paper: Earthformer: Exploring Space-Time Transformers for Earth System Forecasting. Credits to the authors and their repository for the original implementation.</p>"},{"location":"#installation","title":"Installation","text":"<p>The <code>earthformer</code> package is available on PyPI. To install it, run:</p> <pre><code>pip install earthformer\n</code></pre> <p>The <code>earthformer</code> package is also available on conda-forge. To install it, run:</p> <pre><code>conda create -n earthformer python=3.10\nconda activate earthformer\nconda install -c conda-forge mamba\nmamba install -c conda-forge earthformer\n</code></pre>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>I am not the author of the original implementation. This repository is a Python package that wraps the original implementation into a package. If you have any questions about the original implementation, please refer to the amazon-science/earth-forecasting-transformer. The original implementation is licensed under the Apache License, Version 2.0.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v020-aug-9-2023","title":"v0.2.0 - Aug 9, 2023","text":"<p>Added functions to notebook example (#5)</p>"},{"location":"changelog/#v011-aug-9-2023","title":"v0.1.1 - Aug 9, 2023","text":"<p>Added scripts to PyPI distribution (#5)</p>"},{"location":"changelog/#v010-aug-9-2023","title":"v0.1.0 - Aug 9, 2023","text":"<p>Add scripts and notebook (#4)</p>"},{"location":"changelog/#v004-jul-31-2023","title":"v0.0.4 - Jul 31, 2023","text":"<p>Made more dependencies optional</p>"},{"location":"changelog/#v003-jul-31-2023","title":"v0.0.3 - Jul 31, 2023","text":"<p>Made javalang an optional dependency</p>"},{"location":"changelog/#v002-jul-31-2023","title":"v0.0.2 - Jul 31, 2023","text":"<p>Added Earthformer source code</p>"},{"location":"changelog/#v001-jul-30-2023","title":"v0.0.1 - Jul 30, 2023","text":"<p>Initial release</p>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#earthformer.common.array_to_image","title":"<code>array_to_image(array, output, source=None, dtype=None, compress='deflate', **kwargs)</code>","text":"<p>Save a NumPy array as a GeoTIFF using the projection information from an existing GeoTIFF file.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>np.ndarray</code> <p>The NumPy array to be saved as a GeoTIFF.</p> required <code>output</code> <code>str</code> <p>The path to the output image.</p> required <code>source</code> <code>str</code> <p>The path to an existing GeoTIFF file with map projection information. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>np.dtype</code> <p>The data type of the output array. Defaults to None.</p> <code>None</code> <code>compress</code> <code>str</code> <p>The compression method. Can be one of the following: \"deflate\", \"lzw\", \"packbits\", \"jpeg\". Defaults to \"deflate\".</p> <code>'deflate'</code> Source code in <code>earthformer/common.py</code> <pre><code>def array_to_image(\n    array, output, source=None, dtype=None, compress=\"deflate\", **kwargs\n):\n    \"\"\"Save a NumPy array as a GeoTIFF using the projection information from an existing GeoTIFF file.\n\n    Args:\n        array (np.ndarray): The NumPy array to be saved as a GeoTIFF.\n        output (str): The path to the output image.\n        source (str, optional): The path to an existing GeoTIFF file with map projection information. Defaults to None.\n        dtype (np.dtype, optional): The data type of the output array. Defaults to None.\n        compress (str, optional): The compression method. Can be one of the following: \"deflate\", \"lzw\", \"packbits\", \"jpeg\". Defaults to \"deflate\".\n    \"\"\"\n\n    from PIL import Image\n\n    if isinstance(array, str) and os.path.exists(array):\n        array = cv2.imread(array)\n        array = cv2.cvtColor(array, cv2.COLOR_BGR2RGB)\n\n    if output.endswith(\".tif\") and source is not None:\n        with rasterio.open(source) as src:\n            crs = src.crs\n            transform = src.transform\n            if compress is None:\n                compress = src.compression\n\n        # Determine the minimum and maximum values in the array\n\n        min_value = np.min(array)\n        max_value = np.max(array)\n\n        if dtype is None:\n            # Determine the best dtype for the array\n            if min_value &gt;= 0 and max_value &lt;= 1:\n                dtype = np.float32\n            elif min_value &gt;= 0 and max_value &lt;= 255:\n                dtype = np.uint8\n            elif min_value &gt;= -128 and max_value &lt;= 127:\n                dtype = np.int8\n            elif min_value &gt;= 0 and max_value &lt;= 65535:\n                dtype = np.uint16\n            elif min_value &gt;= -32768 and max_value &lt;= 32767:\n                dtype = np.int16\n            else:\n                dtype = np.float64\n        else:\n            dtype = array.dtype\n            if dtype == 'float16':\n                dtype == 'float32'\n\n        # Convert the array to the best dtype\n        array = array.astype(dtype)\n\n        # Define the GeoTIFF metadata\n        if array.ndim == 2:\n            metadata = {\n                \"driver\": \"GTiff\",\n                \"height\": array.shape[0],\n                \"width\": array.shape[1],\n                \"count\": 1,\n                \"dtype\": array.dtype,\n                \"crs\": crs,\n                \"transform\": transform,\n            }\n        elif array.ndim == 3:\n            metadata = {\n                \"driver\": \"GTiff\",\n                \"height\": array.shape[0],\n                \"width\": array.shape[1],\n                \"count\": array.shape[2],\n                \"dtype\": array.dtype,\n                \"crs\": crs,\n                \"transform\": transform,\n            }\n\n        if compress is not None:\n            metadata[\"compress\"] = compress\n        else:\n            raise ValueError(\"Array must be 2D or 3D.\")\n\n        # Create a new GeoTIFF file and write the array to it\n        with rasterio.open(output, \"w\", **metadata) as dst:\n            if array.ndim == 2:\n                dst.write(array, 1)\n            elif array.ndim == 3:\n                for i in range(array.shape[2]):\n                    dst.write(array[:, :, i], i + 1)\n\n    else:\n        img = Image.fromarray(array)\n        img.save(output, **kwargs)\n</code></pre>"},{"location":"common/#earthformer.common.download_file","title":"<code>download_file(url=None, output=None, quiet=False, proxy=None, speed=None, use_cookies=True, verify=True, id=None, fuzzy=False, resume=False, unzip=True, overwrite=False, subfolder=False)</code>","text":"<p>Download a file from URL, including Google Drive shared URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Google Drive URL is also supported. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>Output filename. Default is basename of URL.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Default is False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>verify</code> <code>bool | str</code> <p>Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.</p> <code>True</code> <code>id</code> <code>str</code> <p>Google Drive's file ID. Defaults to None.</p> <code>None</code> <code>fuzzy</code> <code>bool</code> <p>Fuzzy extraction of Google Drive's file Id. Defaults to False.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> <code>False</code> <code>unzip</code> <code>bool</code> <p>Unzip the file. Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> <code>subfolder</code> <code>bool</code> <p>Create a subfolder with the same name as the file. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The output file path.</p> Source code in <code>earthformer/common.py</code> <pre><code>def download_file(\n    url=None,\n    output=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    verify=True,\n    id=None,\n    fuzzy=False,\n    resume=False,\n    unzip=True,\n    overwrite=False,\n    subfolder=False,\n):\n    \"\"\"Download a file from URL, including Google Drive shared URL.\n\n    Args:\n        url (str, optional): Google Drive URL is also supported. Defaults to None.\n        output (str, optional): Output filename. Default is basename of URL.\n        quiet (bool, optional): Suppress terminal output. Default is False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        verify (bool | str, optional): Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string,\n            in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.\n        id (str, optional): Google Drive's file ID. Defaults to None.\n        fuzzy (bool, optional): Fuzzy extraction of Google Drive's file Id. Defaults to False.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n        unzip (bool, optional): Unzip the file. Defaults to True.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n        subfolder (bool, optional): Create a subfolder with the same name as the file. Defaults to False.\n\n    Returns:\n        str: The output file path.\n    \"\"\"\n    try:\n        import gdown\n    except ImportError:\n        print(\n            \"The gdown package is required for this function. Use `pip install gdown` to install it.\"\n        )\n        return\n\n    if output is None:\n        if isinstance(url, str) and url.startswith(\"http\"):\n            output = os.path.basename(url)\n\n    out_dir = os.path.abspath(os.path.dirname(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if isinstance(url, str):\n        if os.path.exists(os.path.abspath(output)) and (not overwrite):\n            print(\n                f\"{output} already exists. Skip downloading. Set overwrite=True to overwrite.\"\n            )\n            return os.path.abspath(output)\n        else:\n            url = github_raw_url(url)\n\n    if \"https://drive.google.com/file/d/\" in url:\n        fuzzy = True\n\n    output = gdown.download(\n        url, output, quiet, proxy, speed, use_cookies, verify, id, fuzzy, resume\n    )\n\n    if unzip:\n        if output.endswith(\".zip\"):\n            with zipfile.ZipFile(output, \"r\") as zip_ref:\n                if not quiet:\n                    print(\"Extracting files...\")\n                if subfolder:\n                    basename = os.path.splitext(os.path.basename(output))[0]\n\n                    output = os.path.join(out_dir, basename)\n                    if not os.path.exists(output):\n                        os.makedirs(output)\n                    zip_ref.extractall(output)\n                else:\n                    zip_ref.extractall(os.path.dirname(output))\n        elif output.endswith(\".tar.gz\") or output.endswith(\".tar\"):\n            if output.endswith(\".tar.gz\"):\n                mode = \"r:gz\"\n            else:\n                mode = \"r\"\n\n            with tarfile.open(output, mode) as tar_ref:\n                if not quiet:\n                    print(\"Extracting files...\")\n                if subfolder:\n                    basename = os.path.splitext(os.path.basename(output))[0]\n                    output = os.path.join(out_dir, basename)\n                    if not os.path.exists(output):\n                        os.makedirs(output)\n                    tar_ref.extractall(output)\n                else:\n                    tar_ref.extractall(os.path.dirname(output))\n\n    return os.path.abspath(output)\n</code></pre>"},{"location":"common/#earthformer.common.download_files","title":"<code>download_files(urls, out_dir=None, filenames=None, quiet=False, proxy=None, speed=None, use_cookies=True, verify=True, id=None, fuzzy=False, resume=False, unzip=True, overwrite=False, subfolder=False)</code>","text":"<p>Download files from URLs, including Google Drive shared URL.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>list</code> <p>The list of urls to download. Google Drive URL is also supported.</p> required <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>filenames</code> <code>list</code> <p>Output filename. Default is basename of URL.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Default is False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>verify</code> <code>bool | str</code> <p>Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.</p> <code>True</code> <code>id</code> <code>str</code> <p>Google Drive's file ID. Defaults to None.</p> <code>None</code> <code>fuzzy</code> <code>bool</code> <p>Fuzzy extraction of Google Drive's file Id. Defaults to False.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> <code>False</code> <code>unzip</code> <code>bool</code> <p>Unzip the file. Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> <code>subfolder</code> <code>bool</code> <p>Create a subfolder with the same name as the file. Defaults to False.</p> <code>False</code> Source code in <code>earthformer/common.py</code> <pre><code>def download_files(\n    urls,\n    out_dir=None,\n    filenames=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    verify=True,\n    id=None,\n    fuzzy=False,\n    resume=False,\n    unzip=True,\n    overwrite=False,\n    subfolder=False,\n):\n    \"\"\"Download files from URLs, including Google Drive shared URL.\n\n    Args:\n        urls (list): The list of urls to download. Google Drive URL is also supported.\n        out_dir (str, optional): The output directory. Defaults to None.\n        filenames (list, optional): Output filename. Default is basename of URL.\n        quiet (bool, optional): Suppress terminal output. Default is False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        verify (bool | str, optional): Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.\n        id (str, optional): Google Drive's file ID. Defaults to None.\n        fuzzy (bool, optional): Fuzzy extraction of Google Drive's file Id. Defaults to False.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n        unzip (bool, optional): Unzip the file. Defaults to True.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n        subfolder (bool, optional): Create a subfolder with the same name as the file. Defaults to False.\n    \"\"\"\n\n    if out_dir is None:\n        out_dir = os.getcwd()\n\n    if filenames is None:\n        filenames = [None] * len(urls)\n\n    for url, output in zip(urls, filenames):\n        if output is None:\n            filename = os.path.join(out_dir, os.path.basename(url))\n        else:\n            filename = os.path.join(out_dir, output)\n\n        download_file(\n            url,\n            filename,\n            quiet,\n            proxy,\n            speed,\n            use_cookies,\n            verify,\n            id,\n            fuzzy,\n            resume,\n            unzip,\n            overwrite,\n            subfolder,\n        )\n</code></pre>"},{"location":"common/#earthformer.common.github_raw_url","title":"<code>github_raw_url(url)</code>","text":"<p>Get the raw URL for a GitHub file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The GitHub URL.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The raw URL.</p> Source code in <code>earthformer/common.py</code> <pre><code>def github_raw_url(url):\n    \"\"\"Get the raw URL for a GitHub file.\n\n    Args:\n        url (str): The GitHub URL.\n    Returns:\n        str: The raw URL.\n    \"\"\"\n    if isinstance(url, str) and url.startswith(\"https://github.com/\") and \"blob\" in url:\n        url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n            \"blob/\", \"\"\n        )\n    return url\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/opengeos/earthformer/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>earthformer could always use more documentation, whether as part of the official earthformer docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/opengeos/earthformer/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up earthformer for local development.</p> <ol> <li> <p>Fork the earthformer repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/earthformer.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv earthformer\n$ cd earthformer/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 earthformer tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and     for PyPy. Check https://github.com/opengeos/earthformer/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"earthformer/","title":"earthformer module","text":"<p>Main module.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The <code>earthformer</code> package is available on PyPI. To install it, run:</p> <pre><code>pip install earthformer\n</code></pre> <p>The <code>earthformer</code> package is also available on conda-forge. To install it, run:</p> <pre><code>conda create -n earthformer python=3.10\nconda activate earthformer\nconda install -c conda-forge mamba\nmamba install -c conda-forge earthformer\n</code></pre>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install earthformer from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/opengeos/earthformer\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use earthformer in a project:</p> <pre><code>import earthformer\n</code></pre>"},{"location":"examples/earthnet2021/","title":"Earthnet2021","text":"<p>The notebook is adapted from the original Earthformer repo here. Credits to the original authors.</p> <p>In this tutorial, we will demonstrate how to apply Earthformer for weather-guided Earth surface forecasting. The goal of the task is to predict the future land surface based on both the previous land surface observations and the future weather. This is an important problem because the future Earth surface can reflect the potential agricultural output and the ecosystem health. We will use the EarthNet2021 dataset. EarthNet2021 contains Sentinel-2 imagery at the 20 m resolution as well as the topography and mesoscale (1.28 km) meteorological variables collected from E-OBS. We will show how Earthformer can help predict the land surface in the future 100 days (5-daily prediction) based on the observational data from the previous 50 days and the weather forecasts.</p> <p>Note: For running this tutorial, you need to use a GPU instance. If you are using SageMaker Studio Lab or Google Colab, simply pick runtime to be <code>GPU</code>.</p> <p>For the purpose of demonstration, we download a small subset of the IID-test split of EarthNet2021.</p> In\u00a0[\u00a0]: Copied! <pre># %pip install earthformer pytorch-lightning==1.7.7\n</pre> # %pip install earthformer pytorch-lightning==1.7.7 In\u00a0[\u00a0]: Copied! <pre># %pip install -q --disable-pip-version-check --no-cache-dir git+https://github.com/NVIDIA/apex.git\n</pre> # %pip install -q --disable-pip-version-check --no-cache-dir git+https://github.com/NVIDIA/apex.git In\u00a0[\u00a0]: Copied! <pre>import earthformer\nimport leafmap\n</pre> import earthformer import leafmap <p>Download Earthnet 2021 dataset.</p> In\u00a0[\u00a0]: Copied! <pre>url = 'https://owncloud.gwdg.de/index.php/s/yHwDqblRPdFnEym/download'\nearthformer.download_file(url, 'datasets/earthnet2021/iid_000.tar.gz')\n</pre> url = 'https://owncloud.gwdg.de/index.php/s/yHwDqblRPdFnEym/download' earthformer.download_file(url, 'datasets/earthnet2021/iid_000.tar.gz') In\u00a0[\u00a0]: Copied! <pre>from omegaconf import OmegaConf\nfrom earthformer.datasets.earthnet.earthnet_dataloader import (\n    EarthNet2021LightningDataModule,\n    EarthNet2021TestDataset,\n)\nfrom pytorch_lightning import Trainer, seed_everything, loggers as pl_loggers\nfrom earthformer.datasets.earthnet.visualization import vis_earthnet_seq\nimport numpy as np\nfrom pathlib import Path\n\nconfig_file = earthformer.get_earthnet_yaml()\nconfig = OmegaConf.load(open(config_file, \"r\"))\nin_len = config.layout.in_len\nout_len = config.layout.out_len\n\nseed = config.optim.seed\ndataset_cfg = OmegaConf.to_object(config.dataset)\n\nseed_everything(seed, workers=True)\n\nmicro_batch_size = 1\n\nearthnet_iid_testset = EarthNet2021TestDataset(\n    subset_name=\"iid\",\n    data_dir=\"./datasets/earthnet2021/iid_test_split\",\n    layout=config.dataset.layout,\n    static_layout=config.dataset.static_layout,\n    highresstatic_expand_t=config.dataset.highresstatic_expand_t,\n    mesostatic_expand_t=config.dataset.mesostatic_expand_t,\n    meso_crop=None,\n    fp16=False,\n)\ntotal_num_test_samples = len(earthnet_iid_testset)\nprint(\"The total number samples in the IID test subset is\", total_num_test_samples)\n</pre> from omegaconf import OmegaConf from earthformer.datasets.earthnet.earthnet_dataloader import (     EarthNet2021LightningDataModule,     EarthNet2021TestDataset, ) from pytorch_lightning import Trainer, seed_everything, loggers as pl_loggers from earthformer.datasets.earthnet.visualization import vis_earthnet_seq import numpy as np from pathlib import Path  config_file = earthformer.get_earthnet_yaml() config = OmegaConf.load(open(config_file, \"r\")) in_len = config.layout.in_len out_len = config.layout.out_len  seed = config.optim.seed dataset_cfg = OmegaConf.to_object(config.dataset)  seed_everything(seed, workers=True)  micro_batch_size = 1  earthnet_iid_testset = EarthNet2021TestDataset(     subset_name=\"iid\",     data_dir=\"./datasets/earthnet2021/iid_test_split\",     layout=config.dataset.layout,     static_layout=config.dataset.static_layout,     highresstatic_expand_t=config.dataset.highresstatic_expand_t,     mesostatic_expand_t=config.dataset.mesostatic_expand_t,     meso_crop=None,     fp16=False, ) total_num_test_samples = len(earthnet_iid_testset) print(\"The total number samples in the IID test subset is\", total_num_test_samples) <p>Each sample in the dataset contains four components:</p> <ul> <li><p>\"highresdynamic\": The Sentinel-2 landcover data. The bands are \"blue\", \"green\", \"red\", \"nir\", \"cloud\". We will use the first four bands in this problem. This dataset will be 5-daily, meaning that there will be one observation in 5 days. The size of each frame is 128x128.</p> </li> <li><p>\"highresstatic\": The elevation of the Sentinel-2 data.</p> </li> <li><p>\"mesodynamic\": The mesoscale weather data. The bands are \"precipitation\", \"pressure\", \"temp mean\", \"temp min\", \"temp max\". The data will be daily and the size of each frame is 80x80.</p> </li> <li><p>\"mesostatic\": The elevation of the mesoscale weather data.</p> </li> </ul> <p>We will use the first 10 frames of \"highresdynamics\" and the auxiliary data (highresstatic, mesodynamic, mesostatic) to predict the future 20 frames of \"highresdynamics\". This is equivalent to using the land surface data in the previous 50 days to predict the land surface data in the coming 100 days.</p> <p>Let's first visualize some data samples:</p> In\u00a0[\u00a0]: Copied! <pre>idx = 1\n\n\ndef process_sample(sample):\n    # High-resolution Earth surface data. The channels are [blue, green, red, nir, cloud]\n    highresdynamic = sample['highresdynamic']\n    highresstatic = sample['highresstatic']\n\n    # The meso-scale data. The channels are [\"precipitation\", \"pressure\", \"temp mean\", \"temp min\", \"temp max\"]\n    mesodynamic = sample['mesodynamic']\n    mesostatic = sample['mesostatic']\n\n    highresdynamic = np.nan_to_num(highresdynamic, nan=0.0, posinf=1.0, neginf=0.0)\n    highresdynamic = np.clip(highresdynamic, a_min=0.0, a_max=1.0)\n    mesodynamic = np.nan_to_num(mesodynamic, nan=0.0)\n    highresstatic = np.nan_to_num(highresstatic, nan=0.0)\n    mesostatic = np.nan_to_num(mesostatic, nan=0.0)\n    return highresdynamic, highresstatic, mesodynamic, mesostatic\n\n\nhighresdynamic, highresstatic, mesodynamic, mesostatic = process_sample(\n    earthnet_iid_testset[idx]\n)\n\nhighresdynamic_in, highresdynamic_out = (\n    highresdynamic[:in_len, ...],\n    highresdynamic[in_len:, ...],\n)\nhighresstatic_in, highresstatic_out = (\n    highresstatic[:in_len, ...],\n    highresstatic[in_len:, ...],\n)\nmesodynamic_in, mesodynamic_out = mesodynamic[:in_len, ...], mesodynamic[in_len:, ...]\nmesostatic_in, mesostatic_out = mesostatic[:in_len, ...], mesostatic[in_len:, ...]\n\nfig_rgb = vis_earthnet_seq(\n    context_np=np.expand_dims(highresdynamic_in, axis=0),\n    target_np=np.expand_dims(highresdynamic_out, axis=0),\n    pred_np=None,\n    layout='N' + config.dataset.layout,\n)\n</pre> idx = 1   def process_sample(sample):     # High-resolution Earth surface data. The channels are [blue, green, red, nir, cloud]     highresdynamic = sample['highresdynamic']     highresstatic = sample['highresstatic']      # The meso-scale data. The channels are [\"precipitation\", \"pressure\", \"temp mean\", \"temp min\", \"temp max\"]     mesodynamic = sample['mesodynamic']     mesostatic = sample['mesostatic']      highresdynamic = np.nan_to_num(highresdynamic, nan=0.0, posinf=1.0, neginf=0.0)     highresdynamic = np.clip(highresdynamic, a_min=0.0, a_max=1.0)     mesodynamic = np.nan_to_num(mesodynamic, nan=0.0)     highresstatic = np.nan_to_num(highresstatic, nan=0.0)     mesostatic = np.nan_to_num(mesostatic, nan=0.0)     return highresdynamic, highresstatic, mesodynamic, mesostatic   highresdynamic, highresstatic, mesodynamic, mesostatic = process_sample(     earthnet_iid_testset[idx] )  highresdynamic_in, highresdynamic_out = (     highresdynamic[:in_len, ...],     highresdynamic[in_len:, ...], ) highresstatic_in, highresstatic_out = (     highresstatic[:in_len, ...],     highresstatic[in_len:, ...], ) mesodynamic_in, mesodynamic_out = mesodynamic[:in_len, ...], mesodynamic[in_len:, ...] mesostatic_in, mesostatic_out = mesostatic[:in_len, ...], mesostatic[in_len:, ...]  fig_rgb = vis_earthnet_seq(     context_np=np.expand_dims(highresdynamic_in, axis=0),     target_np=np.expand_dims(highresdynamic_out, axis=0),     pred_np=None,     layout='N' + config.dataset.layout, ) <p>You may notice that some frames are blank. This is because EarthNet2021 contains a \"data quality mask\" that indicates noise in the data. Earth observations are usually very noisy (due to factors like cloud or observational errors). We simply display the noisy pixels with the black value, and have masked them from the loss functions when training the neural network.</p> <p>Following is the NDVI index calculated via the formula: $NDVI=\\frac{I_{\\text{NIR}} - I_{\\text{red}}}{I_{\\text{NIR}} + I_{\\text{red}}}$. It quantifies vegetation by measuring the difference between near-infrared (which vegetation strongly reflects) and red light (which vegetation absorbs). See the following image from NASA for an illustration of NDVI:</p> <p></p> <p>Thus, one important use-case of our model is that it can also predict the future NDVI. Here, let's visualize the NDVI values of the EarthNet2021 sample.</p> In\u00a0[\u00a0]: Copied! <pre>fig_ndvi = vis_earthnet_seq(\n    context_np=np.expand_dims(highresdynamic_in, axis=0),\n    target_np=np.expand_dims(highresdynamic_out, axis=0),\n    pred_np=None,\n    layout='N' + config.dataset.layout,\n    variable=\"ndvi\",\n)\n</pre> fig_ndvi = vis_earthnet_seq(     context_np=np.expand_dims(highresdynamic_in, axis=0),     target_np=np.expand_dims(highresdynamic_out, axis=0),     pred_np=None,     layout='N' + config.dataset.layout,     variable=\"ndvi\", ) <p>Conventionally, Earth system (e.g., weather and climate) forecasting relies on numerical simulation with complex physical models and are hence both expensive in computation and demanding on domain expertise. With the explosive growth of the spatiotemporal Earth observation data in the past decade, data-driven models that apply Deep Learning (DL) are demonstrating impressive potential for various Earth system forecasting tasks. The Transformer as an emerging DL architecture, despite its broad success in other domains, has limited adoption in this area. In this paper, we propose Earthformer, a space-time Transformer for Earth system forecasting. Earthformer is based on a generic, flexible and efficient space-time attention block, named Cuboid Attention. The idea is to decompose the data into cuboids and apply cuboid-level self-attention in parallel. These cuboids are further connected with a collection of global vectors.</p> <p>Earthformer achieves strong results in synthetic datasets like MovingMNIST and N-body MNIST dataset, and also outperforms non-Transformer models (like ConvLSTM, CNN-U-Net) in SEVIR (precipitation nowcasting) and ICAR-ENSO2021 (El Nino/Southern Oscillation forecasting).</p> <p></p> <p>For more details, you may check our paper.</p> <p>We load the Earthformer pretrained on the training set of EarthNet2021. The model is current rank-1 in EarthNet2021 leaderboard.</p> In\u00a0[\u00a0]: Copied! <pre>import torch\nimport os\nfrom earthformer.train_cuboid_earthnet import CuboidEarthNet2021PLModule\nfrom earthformer.utils.utils import download\n\nsave_dir = \"./experiments\"\n\npl_module = CuboidEarthNet2021PLModule(\n    total_num_steps=None, save_dir=\"./experiments\", oc_file=config_file\n)\n\npretrained_checkpoint_url = \"https://earthformer.s3.amazonaws.com/pretrained_checkpoints/earthformer_earthnet2021.pt\"\nlocal_checkpoint_path = os.path.join(save_dir, \"earthformer_earthnet2021.pt\")\ndownload(url=pretrained_checkpoint_url, path=local_checkpoint_path)\n\nstate_dict = torch.load(local_checkpoint_path, map_location=torch.device(\"cpu\"))\npl_module.torch_nn_module.load_state_dict(state_dict=state_dict)\n</pre> import torch import os from earthformer.train_cuboid_earthnet import CuboidEarthNet2021PLModule from earthformer.utils.utils import download  save_dir = \"./experiments\"  pl_module = CuboidEarthNet2021PLModule(     total_num_steps=None, save_dir=\"./experiments\", oc_file=config_file )  pretrained_checkpoint_url = \"https://earthformer.s3.amazonaws.com/pretrained_checkpoints/earthformer_earthnet2021.pt\" local_checkpoint_path = os.path.join(save_dir, \"earthformer_earthnet2021.pt\") download(url=pretrained_checkpoint_url, path=local_checkpoint_path)  state_dict = torch.load(local_checkpoint_path, map_location=torch.device(\"cpu\")) pl_module.torch_nn_module.load_state_dict(state_dict=state_dict) In\u00a0[\u00a0]: Copied! <pre>pl_module.torch_nn_module.cuda()\npl_module.torch_nn_module.eval()\n\nwith torch.no_grad():\n    pred_seq, loss, in_seq, target_seq, mask = pl_module(\n        {\n            \"highresdynamic\": torch.tensor(\n                np.expand_dims(highresdynamic, axis=0)\n            ).cuda(),\n            \"highresstatic\": torch.tensor(np.expand_dims(highresstatic, axis=0)).cuda(),\n            \"mesodynamic\": torch.tensor(np.expand_dims(mesodynamic, axis=0)).cuda(),\n            \"mesostatic\": torch.tensor(np.expand_dims(mesostatic, axis=0)).cuda(),\n        }\n    )\n    pred_seq_np = pred_seq.detach().cpu().numpy()\n\n    print(\"loss=\", loss.detach().cpu().numpy())\n</pre> pl_module.torch_nn_module.cuda() pl_module.torch_nn_module.eval()  with torch.no_grad():     pred_seq, loss, in_seq, target_seq, mask = pl_module(         {             \"highresdynamic\": torch.tensor(                 np.expand_dims(highresdynamic, axis=0)             ).cuda(),             \"highresstatic\": torch.tensor(np.expand_dims(highresstatic, axis=0)).cuda(),             \"mesodynamic\": torch.tensor(np.expand_dims(mesodynamic, axis=0)).cuda(),             \"mesostatic\": torch.tensor(np.expand_dims(mesostatic, axis=0)).cuda(),         }     )     pred_seq_np = pred_seq.detach().cpu().numpy()      print(\"loss=\", loss.detach().cpu().numpy()) In\u00a0[\u00a0]: Copied! <pre>fig_rgb = vis_earthnet_seq(\n    context_np=np.expand_dims(highresdynamic_in, axis=0),\n    target_np=np.expand_dims(highresdynamic_out, axis=0),\n    pred_np=pred_seq_np,\n    layout='N' + config.dataset.layout,\n)\n</pre> fig_rgb = vis_earthnet_seq(     context_np=np.expand_dims(highresdynamic_in, axis=0),     target_np=np.expand_dims(highresdynamic_out, axis=0),     pred_np=pred_seq_np,     layout='N' + config.dataset.layout, ) In\u00a0[\u00a0]: Copied! <pre>fig_ndvi = vis_earthnet_seq(\n    context_np=np.expand_dims(highresdynamic_in, axis=0),\n    target_np=np.expand_dims(highresdynamic_out, axis=0),\n    pred_np=pred_seq_np,\n    layout='N' + config.dataset.layout,\n    variable=\"ndvi\",\n)\n</pre> fig_ndvi = vis_earthnet_seq(     context_np=np.expand_dims(highresdynamic_in, axis=0),     target_np=np.expand_dims(highresdynamic_out, axis=0),     pred_np=pred_seq_np,     layout='N' + config.dataset.layout,     variable=\"ndvi\", ) <p>You can see that the predictions are close to the ground-truth. In addition, the original dataset contain observational noises and some of the target frames are blank. However, Earthformer is able to give reasonable predictions.</p>"},{"location":"examples/earthnet2021/#weather-guided-earth-surface-forecasting-with-eathformer-on-earthnet2021","title":"Weather-guided Earth Surface Forecasting with Eathformer on EarthNet2021\u00b6","text":""},{"location":"examples/earthnet2021/#load-and-visualize-earthnet2021","title":"Load and Visualize EarthNet2021\u00b6","text":""},{"location":"examples/earthnet2021/#brief-introduction-of-earthformer","title":"Brief Introduction of Earthformer\u00b6","text":""},{"location":"examples/earthnet2021/#load-pretrained-earthformer","title":"Load Pretrained Earthformer\u00b6","text":""},{"location":"examples/earthnet2021/#more-details","title":"More Details\u00b6","text":"<p>For more details, check our code-base https://github.com/amazon-science/earth-forecasting-transformer and the Earthformer paper.</p>"}]}